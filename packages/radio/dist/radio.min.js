function t(t,n,s){const{width:r,height:i}=n,o=e(n,s);!function(t,e,n,s){const r=(Math.min(e,n)-s)/2;t.setAttribute("stroke-width",`${s}`),t.setAttribute("cx",`${e/2}`),t.setAttribute("cy",`${n/2}`),t.setAttribute("r",`${r}`)}(t,r,i,o.dashWidth);const{strokeDasharray:a,strokeDashOffset:d}=function(t,n){const{width:s,height:r}=t,{dashWidth:i,dashLength:o,dashRatio:a}=e(t,n),d=(Math.min(s,r)-i)/2,h=2*Math.PI*d,c=Math.floor((h-a*o)/((1+a)*o)),l=Math.round((h-c*o)/(c+1)*Math.pow(10,3))/Math.pow(10,3);return{strokeDasharray:`${o} ${l}`,strokeDashOffset:"0",dashWidth:i}}(n,o);!function(t,e,n){t.setAttribute("stroke-dasharray",e),t.setAttribute("stroke-dashoffset",n)}(t,a,d)}function e(t,e){const{width:n,height:s}=t;let{dashWidth:r,dashLength:i,dashRatio:o}=e;if(r<0||i<0||o<0)throw new Error("dashWidth, dashLength and dashRatio must be positive numbers");const a=Math.min(n,s);return{dashWidth:r=r>a/2?a/2:r,dashLength:i=i>a?a:i,dashRatio:o=i*(1+o)>a?a-i:o}}const n='\n  <style title="Common styles">\n    :host{\n      --dashed-primary-color: rgba(54, 54, 231, 1);\n      --dashed-primary-light-color: rgba(54, 54, 231, 0.15);\n\n      --dashed-danger-color: rgba(250, 50, 50, 1);\n      --dashed-danger-light-color: rgba(250, 50, 50, 0.15);\n\n      --dashed-success-color: rgba(31, 141, 87, 1);\n      --dashed-success-light-color: rgba(31, 141, 87, 0.15);\n\n      --dashed-fill-color: var(--dashed-primary-light-color);\n      --dashed-outline-color: rgba(129, 129, 193);\n      z-index: 1;\n    }\n\n    :host(:focus) svg.dash {\n      outline: 1px solid var(--dashed-outline-color);\n      outline-offset: 1px;\n    }\n\n    :host([disabled]) {\n      opacity: 0.6;\n      pointer-events: none;\n    }\n\n    svg.dash {\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      fill: none;\n      z-index: -1;\n    }\n\n    svg.dash .border {\n      stroke: var(--dashed-primary-color);\n      fill: var(--dashed-fill-color);\n    }\n\n    svg.dash .border-bottom {\n      stroke: var(--dashed-primary-color);\n    }\n\n    svg.dash .background {\n      fill: var(--dashed-fill-color);\n    }\n  </style>\n';class s extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open",delegatesFocus:!0}),this.dashProps={dashWidth:2,dashLength:4,dashRatio:.5}}get disabled(){return this.hasAttribute("disabled")}set disabled(t){Boolean(t)?this.setAttribute("disabled",""):this.removeAttribute("disabled")}get checked(){return this.hasAttribute("checked")}set checked(t){Boolean(t)?this.setAttribute("checked",""):this.removeAttribute("checked")}get dashProps(){return this._dashProps}set dashProps(t){this._dashProps=t}connectedCallback(){this.render(),this.drawDash()}render(){const t=document.createElement("template");t.innerHTML=`\n      ${n}\n      <style>\n        :host {\n          display: inline-flex;\n          align-items: center;\n          justify-content: center;\n          position: relative;\n          cursor: inherit;\n          outline: none;\n          min-width: 48px;\n        }\n\n        .radio-container {\n          display: inline-block;\n          position: relative;\n          width: 24px;\n          height: 24px;\n        }\n\n        input[type="radio"] {\n          margin: 0;\n          width: 100%;\n          height: 100%;\n          opacity: 0;\n        }\n  \n        svg.dash .outer-circle {\n          stroke: var(--dashed-primary-color);\n          fill: var(--dashed-fill-color);\n        }\n  \n        svg.dash .inner-circle {\n          fill: var(--dashed-danger-color);\n        }\n\n        input[type="radio"]:not(:checked) ~ svg.dash .inner-circle {\n          opacity: 0;\n        }\n\n        input[type="radio"]:checked ~ svg.dash .inner-circle {\n          opacity: 1;\n        }\n      </style>\n      <div class="radio-container">\n        <input type="radio" id="radio" />\n        <svg class="dash">\n          <circle class="outer-circle" />\n          <circle class="inner-circle" />\n        </svg>\n      </div>\n      <label for="radio"><slot></slot></label>\n    `,this.shadowRoot.appendChild(t.content.cloneNode(!0))}drawDash(){const e=this.shadowRoot.querySelector("svg.dash"),[n,s]=[24,24];t(e.querySelector(".outer-circle"),{width:n,height:s},this.dashProps);const r=e.querySelector(".inner-circle");r.setAttribute("cx",`${n/2}`),r.setAttribute("cy",`${s/2}`),r.setAttribute("r","5")}}customElements.define("dashed-radio",s);export{s as DashedRadio};
